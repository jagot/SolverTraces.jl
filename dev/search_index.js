var documenterSearchIndex = {"docs":
[{"location":"columns/#Solver-Trace-Columns-1","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"TraceColumn","category":"page"},{"location":"columns/#SolverTraces.TraceColumn","page":"Solver Trace Columns","title":"SolverTraces.TraceColumn","text":"TraceColumn\n\nBase type for all columns that can appear in a SolverTrace. Each subtype is expected to have a property named fmt containing a formatting string, and to be callable with the current step number as argument, returning the necessary values to render the formatting string, alternatively overload Formatting.format(c::C, i::Integer) where {C<:TraceColumn}.\n\n\n\n\n\n","category":"type"},{"location":"columns/#CurrentStep-1","page":"Solver Trace Columns","title":"CurrentStep","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"CurrentStep\nCurrentStep(num_steps::Integer;\n            lc::LinearColorant=LinearColorant(1, num_steps, red_green_scale()),\n            header::String=repeat(\" \", 2length(digits(num_steps))+3))","category":"page"},{"location":"columns/#SolverTraces.CurrentStep","page":"Solver Trace Columns","title":"SolverTraces.CurrentStep","text":"CurrentStep(num_steps, fmt, lc, header)\n\nTrace column display the current step and total number of iteration, e.g. [ 4/10], with the figures colored according to progress made.\n\n\n\n\n\n","category":"type"},{"location":"columns/#SolverTraces.CurrentStep-Tuple{Integer}","page":"Solver Trace Columns","title":"SolverTraces.CurrentStep","text":"CurrentStep(num_step[; lc, header])\n\nCreate a current step trace column for num_step iterations. The default color scale goes from red to green, and the default header is blank.\n\n\n\n\n\n","category":"method"},{"location":"columns/#Performance-1","page":"Solver Trace Columns","title":"Performance","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"Performance\nPerformance(load::Number, load_name::String=\"Performance\")\nSolverTraces.shift_prefix\nSolverTraces.SI_prefix_convert","category":"page"},{"location":"columns/#SolverTraces.Performance","page":"Solver Trace Columns","title":"SolverTraces.Performance","text":"Performance(load, header, t₀, fmt)\n\nThis trace column can be used to indicate the performance of a calculation, i.e. how many units (grid points, particles, &c) can the algorithm handle per second. The number is shifted to the appropriate order of magnitude, changing the SI prefix to e.g. kHz, MHz, &c.\n\n\n\n\n\n","category":"type"},{"location":"columns/#SolverTraces.Performance","page":"Solver Trace Columns","title":"SolverTraces.Performance","text":"Performance(load[, load_name=\"Performance\"])\n\nConstructe a Performance trace column, for load number of units per iteration.\n\n\n\n\n\n","category":"type"},{"location":"columns/#SolverTraces.shift_prefix","page":"Solver Trace Columns","title":"SolverTraces.shift_prefix","text":"shift_prefix(u, e)\n\nShift the SI prefix of the unit u by e orders of magnitude (which needs to be a multiple of 3).\n\n\n\n\n\n","category":"function"},{"location":"columns/#SolverTraces.SI_prefix_convert","page":"Solver Trace Columns","title":"SolverTraces.SI_prefix_convert","text":"SI_prefix_convert(q)\n\nShift the SI prefix of the quantity q such that no zeros appear before the decimal point, and at most three figures do. Note that this conversion is not necessarily numerically accurate, it is mostly intended for display purposes.\n\nExamples\n\njulia> SolverTraces.SI_prefix_convert(1.0u\"nm\")\n1.0 nm\n\njulia> SolverTraces.SI_prefix_convert(0.10u\"nm\")\n100.0 pm\n\njulia> SolverTraces.SI_prefix_convert(100.0u\"nm\")\n100.0 nm\n\njulia> SolverTraces.SI_prefix_convert(999.0u\"nm\")\n999.0 nm\n\n\n\n\n\n","category":"function"},{"location":"columns/#ScalarColumn-1","page":"Solver Trace Columns","title":"ScalarColumn","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"ScalarColumn\nScalarColumn(n::Function, header::String, ::Type{R}, signed=false) where {R<:Real}","category":"page"},{"location":"columns/#SolverTraces.ScalarColumn","page":"Solver Trace Columns","title":"SolverTraces.ScalarColumn","text":"ScalarColumn(fmt, header, n)\n\nTrace column for any kind of scalar, returned by the callback function n.\n\n\n\n\n\n","category":"type"},{"location":"columns/#SolverTraces.ScalarColumn-Union{Tuple{R}, Tuple{Function,String,Type{R}}, Tuple{Function,String,Type{R},Any}} where R<:Real","page":"Solver Trace Columns","title":"SolverTraces.ScalarColumn","text":"ScalarColumn(n, header, ::Type{R}[, signed=false]) where {R<:Real}\n\nConstruct a ScalarColumn for the callback function n, with a format automatically generated depending on R is an integer or not, and whether it can be signed.\n\n\n\n\n\n","category":"method"},{"location":"columns/#Tolerance-1","page":"Solver Trace Columns","title":"Tolerance","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"Tolerance\nTolerance(target::T,header=\"Tolerance\";print_target::Bool=true) where T\nSolverTraces.base_exp","category":"page"},{"location":"columns/#SolverTraces.Tolerance","page":"Solver Trace Columns","title":"SolverTraces.Tolerance","text":"Tolerance(target, current, fmt, tol_fmt, lc, header)\n\nColumn displaying the progress of the algorithm towards a set target. At each iteration, the current value has to be updated.\n\n\n\n\n\n","category":"type"},{"location":"columns/#SolverTraces.Tolerance-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T","page":"Solver Trace Columns","title":"SolverTraces.Tolerance","text":" Tolerance(target[, header; print_target])\n\nConstruct a new Tolerance column with a set target.\n\n\n\n\n\n","category":"method"},{"location":"columns/#SolverTraces.base_exp","page":"Solver Trace Columns","title":"SolverTraces.base_exp","text":"base_exp(v)\n\nConvert the float v into a tuple of base and exponent in base-10.\n\nExamples\n\njulia> SolverTraces.base_exp(-3.5e2)\n(-3.5000000000000004, 2)\n\n\n\n\n\n","category":"function"},{"location":"columns/#ColumnSeparator-1","page":"Solver Trace Columns","title":"ColumnSeparator","text":"","category":"section"},{"location":"columns/#","page":"Solver Trace Columns","title":"Solver Trace Columns","text":"ColumnSeparator","category":"page"},{"location":"columns/#SolverTraces.ColumnSeparator","page":"Solver Trace Columns","title":"SolverTraces.ColumnSeparator","text":"ColumnSeparator(fmt, header)\n\nSimple separator between columns, that by default simply prints a pipe.\n\n\n\n\n\n","category":"type"},{"location":"colors/#Colors-1","page":"Colors","title":"Colors","text":"","category":"section"},{"location":"colors/#Linear-interpolation-1","page":"Colors","title":"Linear interpolation","text":"","category":"section"},{"location":"colors/#","page":"Colors","title":"Colors","text":"SolverTraces.safe_lerp\nSolverTraces.ilerp\nSolverTraces.sat_ilerp","category":"page"},{"location":"colors/#SolverTraces.safe_lerp","page":"Colors","title":"SolverTraces.safe_lerp","text":"safe_lerp(a, b, t)\n\nSafe implementation of linear interpolation (lerp) between a and b, where t is the linear parameter. If isnan(t), a is returned, and if t is infinite, a or b is returned, depending on the sign.\n\n\n\n\n\n","category":"function"},{"location":"colors/#SolverTraces.ilerp","page":"Colors","title":"SolverTraces.ilerp","text":"ilerp(a, b, t)\n\nLinear interpolation in integer steps.\n\n\n\n\n\n","category":"function"},{"location":"colors/#SolverTraces.sat_ilerp","page":"Colors","title":"SolverTraces.sat_ilerp","text":"sat_ilerp(a, b, t)\n\nSaturated linear interpolation in integer steps, clamped to the range 0:255 (the available colour space).\n\n\n\n\n\n","category":"function"},{"location":"colors/#Color-scales-1","page":"Colors","title":"Color scales","text":"","category":"section"},{"location":"colors/#","page":"Colors","title":"Colors","text":"LinearColorant\nSolverTraces.red_green_scale","category":"page"},{"location":"colors/#SolverTraces.LinearColorant","page":"Colors","title":"SolverTraces.LinearColorant","text":"LinearColorant(a, b, colors)\n\nHelper structure to linearly interpolate between the possible values in colors, where the scalar value a corresponds to the first value and b to the last. If colors is a tuple of two triples, a continuous interpolation between the endpoints will be the result, whereas if it is a vector of Crayons, nearest neighbour interpolation will be performed instead.\n\n\n\n\n\n","category":"type"},{"location":"colors/#SolverTraces.red_green_scale","page":"Colors","title":"SolverTraces.red_green_scale","text":"red_green_scale()\n\nReturn a red–green colour scale; on Windows (with only 16 colours available), this is simply red, yellow, green, on other systems, the end-points are returned instead, for use with sat_ilerp.\n\n\n\n\n\n","category":"function"},{"location":"#SolverTraces.jl-1","page":"Home","title":"SolverTraces.jl","text":"","category":"section"},{"location":"#Usage-example-1","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Using SolverTraces.jl is very easy:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"N = 20 # Number of iterations\n\ntol = Tolerance(1e-3)\ntols = 10 .^ range(0, stop=-3, length=N)\n\ntrace = SolverTrace(N, CurrentStep(N),\n                    ColumnSeparator(),\n                    Performance(100), # Could be number of points processed each iteration\n                    ColumnSeparator(),\n                    tol)\nprint_header(trace)\nfor i = 1:N\n    # Do work\n    # ...\n    # Set which tolerance was achieved in this iteration:\n    tol.current = tols[i]\n\n    SolverTraces.next!(trace)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which will give output similar to this:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<div class=\"repl\">\n<u>           Performance   Tolerance       </u><br/>[<span style=\"color:#ff0000\"> 1/20</span>] │  970.904 kHz │ <span style=\"color:#ff0000\">1.00×10⁰  </span>(10⁻³)<br/>[<span style=\"color:#ff1b00\"> 2/20</span>] │  436.679 kHz │ <span style=\"color:#ff1b00\">6.95×10⁻¹ </span>(10⁻³)<br/>[<span style=\"color:#ff5100\"> 4/20</span>] │  672.164 kHz │ <span style=\"color:#ff5100\">3.36×10⁻¹ </span>(10⁻³)<br/>[<span style=\"color:#ff8600\"> 6/20</span>] │  892.722 kHz │ <span style=\"color:#ff8600\">1.62×10⁻¹ </span>(10⁻³)<br/>[<span style=\"color:#ffbc00\"> 8/20</span>] │    1.074 MHz │ <span style=\"color:#ffbc00\">7.85×10⁻² </span>(10⁻³)<br/>[<span style=\"color:#fff200\">10/20</span>] │    1.168 MHz │ <span style=\"color:#fff200\">3.79×10⁻² </span>(10⁻³)<br/>[<span style=\"color:#d7ff00\">12/20</span>] │    1.207 MHz │ <span style=\"color:#d7ff00\">1.83×10⁻² </span>(10⁻³)<br/>[<span style=\"color:#a1ff00\">14/20</span>] │    1.303 MHz │ <span style=\"color:#a1ff00\">8.86×10⁻³ </span>(10⁻³)<br/>[<span style=\"color:#6bff00\">16/20</span>] │    1.431 MHz │ <span style=\"color:#6bff00\">4.28×10⁻³ </span>(10⁻³)<br/>[<span style=\"color:#36ff00\">18/20</span>] │    1.561 MHz │ <span style=\"color:#36ff00\">2.07×10⁻³ </span>(10⁻³)<br/>[<span style=\"color:#00ff00\">20/20</span>] │    1.685 MHz │ <span style=\"color:#00ff00\">1.00×10⁻³ </span>(10⁻³)<br/>\n</div>","category":"page"},{"location":"#Reference-1","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SolverTrace\nSolverTrace(num_steps::Int,\n            column::TraceColumn = CurrentStep(num_steps),\n            columns::TraceColumn...;\n            io::IO=stdout,\n            num_printouts::Integer=min(num_steps,10),\n            progress_meter::Bool=true,\n            callbacks=(),\n            print_interval = num_printouts > num_steps ? 1 : num_steps÷num_printouts,\n            kwargs...)\nprint_header\nSolverTraces.next!","category":"page"},{"location":"#SolverTraces.SolverTrace","page":"Home","title":"SolverTraces.SolverTrace","text":"SolverTrace(num_steps, i, print_interval, io, progress, columns, callbacks)\n\nRepresents a solver trace for num_steps iterations, i being the current one. Each time next! is called, i is incremented by one, and if a multiple of print_interval is reached, a line is printed in the trace. Optionally (default), a ProgressMeter.Progress is shown as well, providing progress information between solver trace printouts.\n\n\n\n\n\n","category":"type"},{"location":"#SolverTraces.SolverTrace","page":"Home","title":"SolverTraces.SolverTrace","text":"SolverTrace(num_steps[, column=CurrentStep(num_steps), columns...;\n                        io=stdout, num_printouts=10, progress_meter=true,\n                        print_interval, kwargs...])\n\nConstruct a SolverTrace for num_steps iterations, with the columns that are to appear in the solver trace. The solver trace is printed to io, num_printouts lines will appear; alternatively, the print_interval can be specified directly. Below the solver trace, a progressbar is displayed, unless !progress_meter. kwargs... are passed on to ProgressMeter.Progress.\n\n\n\n\n\n","category":"type"},{"location":"#SolverTraces.print_header","page":"Home","title":"SolverTraces.print_header","text":"print_header(s)\n\nPrint the associated header of the SolverTrace s.\n\n\n\n\n\n","category":"function"},{"location":"#SolverTraces.next!","page":"Home","title":"SolverTraces.next!","text":"next!(fun, s::SolverTrace; kwargs...)\n\nSignal to the SolverTrace s that the next iteration has been performed, increasing the internal counter s.i. If a multiple of s.print_interval is reached, a line in the solver trace is printed, formatting each and every trace column, the callback function fun is called, as well as all the registered callbacks.\n\nkwargs are passed on to ProgressMeter.next! to allow e.g. showvalues functionality.\n\n\n\n\n\n","category":"function"}]
}
